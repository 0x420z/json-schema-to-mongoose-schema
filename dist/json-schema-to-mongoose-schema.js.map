{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import _ from 'lodash';\nimport { Schema, SchemaDefinitionProperty } from 'mongoose';\n\n// @ts-ignore\nexport { version } from '../package.json';\n\nexport const schemaTypeMap = {\n  'string': String,\n  'boolean': Boolean,\n  'number': Number,\n  'integer': Number,\n};\n\nexport interface JsonSchemaBaseType {\n  type: keyof typeof schemaTypeMap,\n  pattern?: string,\n  minLength?: number,\n  maxLength?: number,\n  minimum?: number,\n  maximum?: number,\n  enum?: string[],\n  format?: string,\n}\n\nexport interface JsonSchemaArrayType {\n  type: 'array',\n  minItems?: number,\n  maxItems?: number,\n  items: JsonSchemaArrayType | JsonSchemaBaseType | JsonSchemaObjectType,\n}\n\nexport interface JsonSchemaObjectType {\n  type: 'object',\n  properties: { [k: string | symbol]: JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType },\n  required?: string[],\n}\n\nexport interface JsonSchema {\n  $schema: string,\n  definitions: { [k: string | symbol]: JsonSchemaObjectType },\n}\n\nexport type Validation = [((val: any[]) => boolean), string] | [];\n\nexport const genArrayLimit = (minItems?: number, maxItems?: number): Validation => {\n  const hasMin = typeof minItems === 'number';\n  const hasMax = typeof maxItems === 'number';\n\n  if (hasMin && hasMax) {\n    return [\n      (val: any[]) => (val.length >= minItems && val.length <= maxItems),\n      `{PATH} is not within range (${minItems} to ${maxItems} items)`\n    ];\n  } else if (hasMin) {\n    return [\n      (val: any[]) => (val.length >= minItems),\n      `{PATH} must have at least ${minItems} items`\n    ];\n  } else if (hasMax) {\n    return [\n      (val: any[]) => (val.length <= maxItems),\n      `{PATH} exceeds the limit of ${maxItems} items`\n    ];\n  }\n\n  return [];\n}\n\nexport const typeHandler = (schemaType: JsonSchemaBaseType, required?: boolean) => {\n  const {\n    type: schemaTypeType,\n    pattern: match,\n    minLength,\n    maxLength,\n    minimum: min,\n    maximum: max,\n    format,\n    enum: enumValues,\n  } = schemaType;\n\n  if (schemaTypeMap.hasOwnProperty(schemaTypeType)) {\n    return {\n      type: (format === 'date-time') ? Date : schemaTypeMap[schemaTypeType],\n      match,\n      minLength,\n      maxLength,\n      min,\n      max,\n      enum: enumValues,\n      required,\n    };\n  }\n\n  throw new Error(`Unsupported schema type: ${schemaType}`);\n};\n\nexport const handleProperty = (\n  key: string,\n  property: JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType,\n  subSchemaHandler: (\n    key: string,\n    subSchema: JsonSchemaObjectType | JsonSchemaArrayType,\n    required?: string[],\n  ) => void,\n  subTypeHandler: (\n    key: string,\n    schemaType: JsonSchemaBaseType,\n  ) => void,\n) => {\n  if (!_.isPlainObject(property)) {\n    throw new Error(`Invalid JSON Schema, ${key} is not an object`);\n  }\n\n  if (!property.hasOwnProperty('type')) {\n    throw new Error(`Invalid JSON Schema, ${key} is missing type`);\n  }\n\n  if ((/array|object/).test(property.type)) {\n    subSchemaHandler(key, property as JsonSchemaObjectType | JsonSchemaArrayType);\n    return;\n  }\n\n  subTypeHandler(key, property as JsonSchemaBaseType);\n};\n\nexport const traverseDefinitions = (\n  definitions: JsonSchema['definitions'] | JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType,\n  definitionKey?: string,\n) => {\n  const schema = new Schema();\n\n  const schemaDefinition = (\n    definitionKey\n  ) ? (\n    (definitions as JsonSchema['definitions'])[definitionKey]\n  ) : (\n    definitions as JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType\n  );\n\n  if (!_.isPlainObject(schemaDefinition)) {\n    throw new Error(`Invalid JSON Schema, definition is not an object`);\n  }\n\n  if (!schemaDefinition.hasOwnProperty('type')) {\n    throw new Error(`Invalid JSON Schema, missing type while traversing definitions`);\n  }\n\n  if (definitionKey && schemaDefinition.type !== 'object') {\n    throw new Error(`Invalid JSON Schema, expected type to be 'object' for ${definitionKey}`);\n  }\n\n  if (schemaDefinition.type === 'object') {\n    const subSchemas: [string, (JsonSchemaObjectType | JsonSchemaArrayType)][] = [];\n\n    _.forEach(\n      (schemaDefinition as JsonSchemaObjectType).properties || [],\n      (p, key) => {\n        handleProperty(\n          key,\n          p,\n          (key, subSchema) => {\n            subSchemas.push([key, subSchema]);\n          },\n          (key, schemaType) => {\n            schema.add(\n              {\n                [key]: typeHandler(\n                  schemaType,\n                  _.includes((schemaDefinition as JsonSchemaObjectType).required || [], key),\n                ) as SchemaDefinitionProperty<any>,\n              },\n            );\n          }\n        );\n      }\n    );\n\n    _.forEach(subSchemas, ([key, subSchema]) => {\n      const subSchemaType = (\n        subSchema.type === 'array'\n      ) ? (\n        [traverseDefinitions(subSchema.items)]\n      ) : (\n        traverseDefinitions(subSchema)\n      );\n\n      const validate = genArrayLimit(\n        (subSchema as JsonSchemaArrayType).minItems,\n        (subSchema as JsonSchemaArrayType).maxItems,\n      );\n\n      schema.add(\n        {\n          [key]: {\n            type: subSchemaType,\n            required: _.includes((schemaDefinition as JsonSchemaObjectType).required || [], key),\n            validate,\n          }\n        },\n      );\n    });\n\n    return schema;\n  }\n\n  if (schemaDefinition.type === 'array') {\n    schema.add(\n      {\n        type: traverseDefinitions(schemaDefinition.items),\n      },\n    );\n\n    return schema;\n  }\n\n  return typeHandler(\n    schemaDefinition,\n    false,\n  ) as SchemaDefinitionProperty<any>;\n};\n\nconst jsonSchemaToMongooseSchema = (jsonSchema: JsonSchema, definitionKey: string) => {\n  if (!(/draft-(0[4-9]|[1-9][0-9])/).test(_.get(jsonSchema, '$schema', 'draft-00'))) {\n    throw new Error('Invalid JSON Schema, expected $schema to be draft-04 or greater');\n  }\n\n  const definitions = jsonSchema.definitions;\n\n  if (_.isPlainObject(definitions) && definitions.hasOwnProperty(definitionKey)) {\n    const schema = traverseDefinitions(definitions, definitionKey);\n\n    return schema as Schema;\n  }\n\n  throw new Error('Invalid JSON Schema');\n};\n\nexport default jsonSchemaToMongooseSchema;\n"],
  "mappings": "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",
  "names": []
}
