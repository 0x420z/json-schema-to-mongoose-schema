{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import _ from 'lodash';\nimport { Schema, SchemaDefinitionProperty } from 'mongoose';\n\n// @ts-ignore\nexport { version } from '../package.json';\n\nexport const schemaTypeMap = {\n  'string': String,\n  'boolean': Boolean,\n  'number': Number,\n  'integer': Number,\n};\n\nexport interface JsonSchemaBaseType {\n  type: keyof typeof schemaTypeMap;\n  pattern?: string;\n  minLength?: number;\n  maxLength?: number;\n  minimum?: number;\n  maximum?: number;\n  enum?: string[];\n  format?: string;\n}\n\nexport interface JsonSchemaArrayType {\n  type: 'array';\n  minItems?: number;\n  maxItems?: number;\n  items: JsonSchemaValidTypes | JsonSchemaAnyOfType;\n}\n\nexport interface JsonSchemaObjectType {\n  type: 'object';\n  properties: {\n    [k: string | symbol]: JsonSchemaValidTypes | JsonSchemaAnyOfType;\n  };\n  required?: string[];\n}\n\nexport type JsonSchemaValidTypes = JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType;\n\nexport interface JsonSchemaAnyOfType {\n  anyOf: JsonSchemaObjectType[];\n}\n\nexport interface JsonSchema {\n  $schema: string;\n  definitions: { [k: string | symbol]: JsonSchemaObjectType };\n}\n\nexport type Validation = [((val: any[]) => boolean), string] | [];\n\nexport const genArrayLimit = (minItems?: number, maxItems?: number): Validation => {\n  const hasMin = typeof minItems === 'number';\n  const hasMax = typeof maxItems === 'number';\n\n  if (hasMin && hasMax) {\n    return [\n      (val: any[]) => (val.length >= minItems && val.length <= maxItems),\n      `{PATH} is not within range (${minItems} to ${maxItems} items)`\n    ];\n  } else if (hasMin) {\n    return [\n      (val: any[]) => (val.length >= minItems),\n      `{PATH} must have at least ${minItems} items`\n    ];\n  } else if (hasMax) {\n    return [\n      (val: any[]) => (val.length <= maxItems),\n      `{PATH} exceeds the limit of ${maxItems} items`\n    ];\n  }\n\n  return [];\n}\n\nexport const typeHandler = (schemaType: JsonSchemaBaseType, required?: boolean) => {\n  const {\n    type: schemaTypeType,\n    pattern: match,\n    minLength,\n    maxLength,\n    minimum: min,\n    maximum: max,\n    format,\n    enum: enumValues,\n  } = schemaType;\n\n  if (schemaTypeMap.hasOwnProperty(schemaTypeType)) {\n    return {\n      type: (format === 'date-time') ? Date : schemaTypeMap[schemaTypeType],\n      match,\n      minLength,\n      maxLength,\n      min,\n      max,\n      enum: enumValues,\n      required,\n    };\n  }\n\n  throw new Error(`Unsupported schema type: ${schemaType}`);\n};\n\nexport const processAnyOf = (property: JsonSchemaAnyOfType) => {\n  const { anyOf } = property;\n\n  if (!_.isArray(anyOf)) {\n    throw new Error('Invalid JSON Schema, expected anyOf to be an array');\n  }\n\n  if (anyOf.length === 0) {\n    throw new Error('Invalid JSON Schema, expected anyOf to have at least one item');\n  }\n\n  if (anyOf.length === 1) {\n    throw new Error('Invalid JSON Schema, expected anyOf to have more than one item');\n  }\n\n  const onlyObjects = anyOf.reduce((a, b) => {\n    return a && (b.type === 'object');\n  }, true);\n\n  if (!onlyObjects) {\n    throw new Error('Invalid JSON Schema, expected anyOf to only contain objects');\n  }\n\n  return anyOf.reduce(\n    (a, b) => {\n      _.forEach(b.properties, (value, key) => {\n        let subProperty: JsonSchemaValidTypes;\n\n        if ((value as JsonSchemaAnyOfType).anyOf) {\n          subProperty = processAnyOf((value as JsonSchemaAnyOfType));\n        } else {\n          subProperty = value as JsonSchemaValidTypes;\n        }\n\n        if (!a.properties.hasOwnProperty(key)) {\n          a.properties[key] = subProperty;\n        } else {\n          if (\n            (a.properties[key] as JsonSchemaValidTypes).type !== subProperty.type\n          ) {\n            console.log((a.properties[key] as JsonSchemaValidTypes), subProperty);\n            throw new Error(\n              `Invalid JSON Schema, expected anyOf to only contain objects with identical properties`\n            );\n          }\n\n          a.properties[key] = _.mergeWith(a.properties[key], subProperty, (objValue, srcValue) => {\n            if (_.isArray(objValue)) {\n              return objValue.concat(srcValue);\n            }\n\n            if (_.isPlainObject(objValue)) {\n              return _.merge(objValue, srcValue);\n            }\n\n            if (objValue !== srcValue) {\n              throw new Error(\n                `Invalid JSON Schema, values of types other than object or array must be identical`\n              );\n            }\n\n            return objValue;\n          });\n        }\n      });\n\n      a.required = (a.required || []).concat(b.required || []);\n\n      return a;\n    },\n    {\n      type: 'object',\n      properties: {},\n      required: [],\n    } as JsonSchemaObjectType,\n  );\n};\n\nexport const handleProperty = (\n  key: string,\n  property: JsonSchemaBaseType | JsonSchemaObjectType | JsonSchemaArrayType | JsonSchemaAnyOfType,\n  subSchemaHandler: (\n    key: string,\n    subSchema: JsonSchemaObjectType | JsonSchemaArrayType,\n    required?: string[],\n  ) => void,\n  subTypeHandler: (\n    key: string,\n    schemaType: JsonSchemaBaseType,\n  ) => void,\n) => {\n  if (!_.isPlainObject(property)) {\n    throw new Error(`Invalid JSON Schema, ${key} is not an object`);\n  }\n\n  if (!property.hasOwnProperty('type') && !property.hasOwnProperty('anyOf')) {\n    throw new Error(`Invalid JSON Schema, ${key} is missing type`);\n  }\n\n  let finalProperty: JsonSchemaValidTypes;\n\n  if (property.hasOwnProperty('anyOf')) {\n    finalProperty = processAnyOf(property as JsonSchemaAnyOfType);\n  } else {\n    finalProperty = property as JsonSchemaValidTypes;\n  }\n\n  if ((/array|object/).test(finalProperty.type)) {\n    subSchemaHandler(key, finalProperty as JsonSchemaObjectType | JsonSchemaArrayType);\n    return;\n  }\n\n  subTypeHandler(key, finalProperty as JsonSchemaBaseType);\n};\n\nexport const traverseDefinitions = (\n  definitions: JsonSchema['definitions'] | JsonSchemaValidTypes | JsonSchemaAnyOfType,\n  definitionKey?: string,\n) => {\n  const schema = new Schema();\n\n  const schemaDefinition = (\n    definitionKey\n  ) ? (\n    (definitions as JsonSchema['definitions'])[definitionKey]\n  ) : (\n    (\n      definitions.hasOwnProperty('anyOf')\n    ) ? (\n      processAnyOf(definitions as JsonSchemaAnyOfType)\n    ) : (\n      definitions as JsonSchemaValidTypes\n    )\n  );\n\n  if (!_.isPlainObject(schemaDefinition)) {\n    throw new Error(`Invalid JSON Schema, definition is not an object`);\n  }\n\n  if (!schemaDefinition.hasOwnProperty('type')) {\n    throw new Error(`Invalid JSON Schema, missing type while traversing definitions`);\n  }\n\n  if (definitionKey && schemaDefinition.type !== 'object') {\n    throw new Error(`Invalid JSON Schema, expected type to be 'object' for ${definitionKey}`);\n  }\n\n  if (schemaDefinition.type === 'object') {\n    const subSchemas: [string, (JsonSchemaObjectType | JsonSchemaArrayType)][] = [];\n\n    _.forEach(\n      (schemaDefinition as JsonSchemaObjectType).properties || [],\n      (p, key) => {\n        handleProperty(\n          key,\n          p,\n          (key, subSchema) => {\n            subSchemas.push([key, subSchema]);\n          },\n          (key, schemaType) => {\n            schema.add(\n              {\n                [key]: typeHandler(\n                  schemaType,\n                  _.includes((schemaDefinition as JsonSchemaObjectType).required || [], key),\n                ) as SchemaDefinitionProperty<any>,\n              },\n            );\n          }\n        );\n      }\n    );\n\n    _.forEach(subSchemas, ([key, subSchema]) => {\n      const subSchemaType = (\n        subSchema.type === 'array'\n      ) ? (\n        [traverseDefinitions(subSchema.items as JsonSchemaValidTypes)]\n      ) : (\n        traverseDefinitions(subSchema)\n      );\n\n      const validate = genArrayLimit(\n        (subSchema as JsonSchemaArrayType).minItems,\n        (subSchema as JsonSchemaArrayType).maxItems,\n      );\n\n      schema.add(\n        {\n          [key]: {\n            type: subSchemaType,\n            required: _.includes((schemaDefinition as JsonSchemaObjectType).required || [], key),\n            validate,\n          }\n        },\n      );\n    });\n\n    return schema;\n  }\n\n  if (schemaDefinition.type === 'array') {\n    schema.add(\n      {\n        type: traverseDefinitions(schemaDefinition.items as JsonSchemaValidTypes),\n      },\n    );\n\n    return schema;\n  }\n\n  return typeHandler(\n    schemaDefinition,\n    false,\n  ) as SchemaDefinitionProperty<any>;\n};\n\nconst jsonSchemaToMongooseSchema = (jsonSchema: JsonSchema, definitionKey: string) => {\n  if (!(/draft-(0[4-9]|[1-9][0-9])/).test(_.get(jsonSchema, '$schema', 'draft-00'))) {\n    throw new Error('Invalid JSON Schema, expected $schema to be draft-04 or greater');\n  }\n\n  const definitions = jsonSchema.definitions;\n\n  if (_.isPlainObject(definitions) && definitions.hasOwnProperty(definitionKey)) {\n    const schema = traverseDefinitions(definitions, definitionKey);\n\n    return schema as Schema;\n  }\n\n  throw new Error('Invalid JSON Schema');\n};\n\nexport default jsonSchemaToMongooseSchema;\n"],
  "mappings": "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",
  "names": []
}
